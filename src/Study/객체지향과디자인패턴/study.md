## 02 객체지향
### 데미테르의 법칙
* 메서드에서 생성한 객체의 메서드만 호출
* 파라미터로 받은 객체의 메서드만 호출
* 필드로 참조하는 객체의 메서드만 호출

#### 신문 배달부와 지갑
 신문 배달부가 고객에게 요금을 받아가는 상황에서 신문 배달부는 고객의 주머니에서 지갑을 꺼내서
 돈이 들었는지 확인한 뒤에, 돈을 가져가지 않는다.
 
* 데미테르 법칙을 지키지 않는 전형적인 증상 두가지
  * 연속된 get 메서드 호출
    * 임시 변수의 get 호출이 많음

이런 경우에는 캡슐화하도록 노력해야 한다.

## 03 다형성과 추상타입
객체 지향이 주는 장점은 구현 변경의 유연함이다.

이 장에서는 추상화가 주는 유연함에 대한 내용을 공부해 볼 것이다.
### 추상 타입을 이용한 구현 교체의 유연함
콘크리트(구상) 클래스를 직접 사용하면 문제가 되나?
처음에는 문제가 되지 않는다

그러나 새로 수정이 필요한 경우 유지보수를 어렵게 만든다.
새로운 변화가 생길때 마다 계속 영향을 받는다.
* 다형성을 이용하여 객체를 생성하는 기능을 별도로 분리한다.
* 추상화를 통해서 변경의 유연함을 얻을 수 있다.
* 추상화 되어 있지 않은 코드는 주로 동일 구조를 갖는 if-else 블록으로 드러난다.

## 04 재사용: 상속보단 조립
* 단점
  * 상속은 상위 클래스의 변경을 어렵게 만든다. 변경의 여파에 따라 자손클래스에 전파되므로 변경이 어렵다.
  * 유사한 기능을 확장하는 과정에서 클래스의 개수가 불필요하게 증가 할 수 있다.
  * 상속 자체를 잘못 사용할 수 있다.
#### 객체 조립을 이용하여 해결한다.

## 05 설계원칙: SOLID
SOLID 설계원칙은 다음의 다섯 가지 원칙으로 구성된다.
* 단일 책임 원칙(Single responsibility principle)
* 개방-폐쇄 원칙(Open-closed principle)
* 리스코프 치환 원칙(Liskov substitution principle)
* 인터페이스 분리 원칙(Interface seqregation principle)
* 의존 역전 원칙(Dependency inversion principle)

#### 단일 책임 원칙
클래스는 단 한 개의 책임을 가져야 한다.
클래스를 변경하는 이유는 단 한 개여야 한다.

* 단일 책임 원칙 위반을 하게 되면
  * 코드를 절차 지향적으로 만들어 변경을 어렵게 만든다. -> 책임을 분리하면 변경의 여파를 줄일 수 있다.
  * 재사용을 어렵게 한다.
  * 필요하지 않는 패키지까지 필요하게 만든다.
* 책임의 단위란 변화되는 부분과 관련된다. 각각의 책임은 서로 다른 이유로 변경되고, 서로 다른 비율로 변경되는 특징이 있다.
따라서 서로 다른 이유로 바뀌는 책임들이 한 클래스에 함께 포함되어 있다면 이 클래스는 단일 책임 원칙을 어기고 있다고 볼 수 있다.

어떻게 하면 단일 책임 원칙을 지킬 수 있을까? -> 메서드를 실행하는 것이 누구인지 확인해 보는 것이다.

클래스의 사용자들이 서로 다른 메서드들을 사용한다면 각각 다른 책임에 속할 가능성이 높고, 따라서 책임 분리 후보가 될 수 있다.
