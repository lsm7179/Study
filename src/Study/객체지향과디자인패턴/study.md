## 02 객체지향
### 데미테르의 법칙
* 메서드에서 생성한 객체의 메서드만 호출
* 파라미터로 받은 객체의 메서드만 호출
* 필드로 참조하는 객체의 메서드만 호출

#### 신문 배달부와 지갑
 신문 배달부가 고객에게 요금을 받아가는 상황에서 신문 배달부는 고객의 주머니에서 지갑을 꺼내서
 돈이 들었는지 확인한 뒤에, 돈을 가져가지 않는다.
 
* 데미테르 법칙을 지키지 않는 전형적인 증상 두가지
  * 연속된 get 메서드 호출
    * 임시 변수의 get 호출이 많음

이런 경우에는 캡슐화하도록 노력해야 한다.

## 03 다형성과 추상타입
객체 지향이 주는 장점은 구현 변경의 유연함이다.

이 장에서는 추상화가 주는 유연함에 대한 내용을 공부해 볼 것이다.
### 추상 타입을 이용한 구현 교체의 유연함
콘크리트(구상) 클래스를 직접 사용하면 문제가 되나?
처음에는 문제가 되지 않는다

그러나 새로 수정이 필요한 경우 유지보수를 어렵게 만든다.
새로운 변화가 생길때 마다 계속 영향을 받는다.
* 다형성을 이용하여 객체를 생성하는 기능을 별도로 분리한다.
* 추상화를 통해서 변경의 유연함을 얻을 수 있다.
* 추상화 되어 있지 않은 코드는 주로 동일 구조를 갖는 if-else 블록으로 드러난다.

## 04 재사용: 상속보단 조립
* 단점
  * 상속은 상위 클래스의 변경을 어렵게 만든다. 변경의 여파에 따라 자손클래스에 전파되므로 변경이 어렵다.
  * 유사한 기능을 확장하는 과정에서 클래스의 개수가 불필요하게 증가 할 수 있다.
  * 상속 자체를 잘못 사용할 수 있다.
#### 객체 조립을 이용하여 해결한다.

## 05 설계원칙: SOLID
SOLID 설계원칙은 다음의 다섯 가지 원칙으로 구성된다.
* 단일 책임 원칙(Single responsibility principle)
* 개방-폐쇄 원칙(Open-closed principle)
* 리스코프 치환 원칙(Liskov substitution principle)
* 인터페이스 분리 원칙(Interface seqregation principle)
* 의존 역전 원칙(Dependency inversion principle)

#### 단일 책임 원칙
클래스는 단 한 개의 책임을 가져야 한다.
클래스를 변경하는 이유는 단 한 개여야 한다.

* 단일 책임 원칙 위반을 하게 되면
  * 코드를 절차 지향적으로 만들어 변경을 어렵게 만든다. -> 책임을 분리하면 변경의 여파를 줄일 수 있다.
  * 재사용을 어렵게 한다.
  * 필요하지 않는 패키지까지 필요하게 만든다.
* 책임의 단위란 변화되는 부분과 관련된다. 각각의 책임은 서로 다른 이유로 변경되고, 서로 다른 비율로 변경되는 특징이 있다.
따라서 서로 다른 이유로 바뀌는 책임들이 한 클래스에 함께 포함되어 있다면 이 클래스는 단일 책임 원칙을 어기고 있다고 볼 수 있다.

어떻게 하면 단일 책임 원칙을 지킬 수 있을까? -> 메서드를 실행하는 것이 누구인지 확인해 보는 것이다.

클래스의 사용자들이 서로 다른 메서드들을 사용한다면 각각 다른 책임에 속할 가능성이 높고, 따라서 책임 분리 후보가 될 수 있다.
#### 개방 폐쇄 원칙
확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
기능을 변경하거나 확장할 수 있으면서
그 기능을 사용하는 코드는 수정하지 않는다.
추상화와 다형성이 제대로 지켜지지 않는 코드는 개방 폐쇄 원칠을 어기게 된다.
* 개방 폐쇄 원칙이 깨질 때의 주요 증상
  * 다운 캐스팅을 한다.
  * 비슷한 if-else 블록이 존재한다.
* 변화되는 부분을 추상화하지 못하면(또는 안하면) 개방 폐쇄 원칙을 지킬 수 없게 되어 
  시간이 흐를수록 기능 변경이나 확장을 어렵게 만든다.
#### 리스코프 치환 원칙
상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
개념적으로 상속 관계에 있는 것처럼 보일지라도 실제 구현에서는 상속관계가 아닐 수도 있다. 
-> 이럴땐 별개의 타입으로 구현해 주어야 한다.
* 리스코프 치환 원칙은 기능의 명세(또는 계약)에 대한 내용이다.
  * 몀시된 명세에서 벗어난 값을 리턴한다.
  * 명시된 명세에서 벗어난 익셉션을 발생한다.
  * 명시된 명세에서 벗어난 기능을 수행한다.
#### 인터페이스 분리 원칙
인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

'클라이언트는 자신이 사용하는 메서드에만 의존해야 한다.'
