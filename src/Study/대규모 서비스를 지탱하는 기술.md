# 대규모 서비스를 지탱하는 기술

### 01. 대규모 웹 서비스 개발 오리엔테이션
```text
1장 대규모 서비스와 소규모 서비스
이 책에서 설명하는 것
• 대규모 웹 서비스 개발이란?
• 대규모 데이터를 다룰 때의 고ᅡ제, 다루기 위한 기본적인 사고방식과 요령.
  예를 들어 OS의 캐시(cache) 기능이나 대규모 데이터를 전제로 한 DB 운용방법
• 알고리즘과 데이터 구조 선택의 중요성. 대규모 데이터를 예로 생각해본다.
• RDBMS(Relational DataBase Management System)로 모두 다룰 수 없는 규모의 데이터 처 리방법. 그 예로 전문(全文) 검색 엔진 만드는 법을 살펴본다.
• 대규모 서비스가 될 것을 전제로 한 서버/인프라 시스템의 예와 개념

소규모 서비스와 대규모 서비스의 차이
확장성 확보, 부하분산 필요 : 최근 10년 동안의 트렌드로는 이른바 ‘스케일아웃(scale-out)’ 이 이 문제에 대한 전략의 기초가 된다.
다중성 확보 : 시스템은 특정 서버가 고장 나거나 성능이 저하되더라도 서비스를 계속 할 수 있는 구성으로 할 필요가 있다.
효율적 운용 필요: 모니터링을 효율적으로 해야 한다.
2장 계속 성장하는 서비스와 대규모화의 벽
프록시 → ap서버 
 서버는 로드밸런서나 스케일아웃으로 잡을 수 있다.
io부하는 디비부하가 있어서 단순히 늘리는 것만으로는 할 수 없다.
결론: 서버는 쉽게 증축가능하고 디비는 고려할 것이 많다.
디스크시크스 최소화 하기 알고리즘을 사용해서 검색하기 데이터 압축을 하면 더 적게 검색 할 수 있다.
```
```text
8강 os의 캐시 구조

컴퓨터 구조 강의가 생각남.
디스크랑 메모리간의 접근 시간 로딩시간 차이가 나서 디스크에서 읽은것을 적재하는 방식
디스크에서 데이터를 읽고 메모리에 적재를 하는데 프로세스에 전담하지 않고 101 ~ 104까지 데이터가 있을 예정이야 라고 했을때
101번지만 전달하지 않고 블록단위로 던져주는게 페이지 캐시라고 한다. 리눅스는 페이지 캐시를 한다.
메모리 사용량이 높다고 겁먹지말라 큐형식이므로 관리하고 있다.
메모리가 많으면 디스크상에 필요한 파일들을 다 적재를 할 수 있으므로 좋을거라고 예상하지만 막상 그렇지 않다.

11강 인덱스의 중요성
데이터를 탐색하기 좋게 되어 있다.
b-tree에 대해서 설명해주고 있다.
부모노드에서 여러개 자식을 나눌수 있다.
그런 자식을 많이 가질 수 있다는 특징 때문에 b-tree를 사용하면 원하는 검색을 빨리 찾을 수 있다. 부모가 가지고 있지 않으면 자식을 찾는다. 카테고리 같은 형식이지 않을까 하는 생각이 든다.
찾기 횟수가 줄어 든다라고 한다.mysql은 b+tree를 사용한다.
간단히 얘기하면 b+tree는 부모가 자식의 포인터를 가지고 있다.
```

### 05. 대규모 데이터 처리 실전 입문
```text
14장 용도특화형 인덱싱
db → 배치  → 인덱스서버(검색용) → ap
하테나? 용도특화형인덱스
Trie 기반의 정규표현 Common Prefix Search(공통접두사검색)
이런 상황이 오면 검색엔진을 고민해보자.
- 대량의 데이터에서 검색하고자 한다.
  • 빠르게 검색하고자 한다.
  • '좋은느낌(Feeling Lucky)’ 과 같은 문서를 상위로
15장 이론과 실전 양쪽과의 싸움
‘이론과 실전 양쪽에서 공격해야 한다’ 는 특성이 상당히 존재한다는 것을 알았을 것이다.
어느 한쪽으로 치우쳐져서는 안된다.
컴퓨터의 문제에 이르는 길을 어떻게 발견할까?
하고자 하는 것을 컴퓨터의 문제로 전환해서 해결에 이르 는 길을 찾을 수 있는지 여부다.
결국，알고리즘/ 데이터 구조로 무언가를 실행할 때 해당 알고리즘의 데이터 구
조를 사용해서 어떤 게 가능한지를 어느 정도 머릿속에 넣어두지 않으면 이럴 때 딱 떠오르지 않는다. 덧붙여서 이론적으로 배울 뿐만 아니라 응용을 위한 이치를 어느 정도 익혀두는 것도 중요하다.
다음번 읽을 챕터 제9장, 제10장 에서는 검색엔진을 만든다.
```

### 09. 전문 검색 기술 도전
```text
24장 전문 검색기술의 응용범위
역 인덱스 Dictionary라는부분과Postings라는부분
검색엔진의 시스템 코어는 C++로 구현되어 있고, Perl과의 인터페이스는 Thrift라는 라이브러리로통신하고 있다.
북마크의 검색기능
25장 검색 시스템의 아키텍처
- 검색이 가능하기까지
- 크롤링
- 저장
- 인덱싱
- 검색
- 스코어링 검색결과를 어떤 순서로 표시해줄 것인가(랭킹)
- 결과표시
전문 검색의 종류
- grep 형 grep과 Shunsaku
- Suffix형 Sedue
- 역 인덱스형 주류(Google도 채용)
grep은 단순검색이다 단순 검색KMP법, BM법 ⇒ O(mn), text:m, word: n
장점 즉시성이 좋다. 문서가 갱신되더라도 바로 검색할 수 있다. 검색누락이없다.
병렬화하기가 매우 간단하다.
반면 대규모 환경에서 쉽게 만들려고 하면 다소 무리가 따를 듯하다.

suffix형 문서를 검색 가능한 형태로 가지고 있으며 전부 메모리에 올릴 수 있는 형태가 된 다. 8장 과제 참고실제 이 아키텍처를 가진 엔진은 좀처럼 구현하기 어렵다.

역 인덱스는 문서 전체를 가지고 있는 것이 아니다.
역인덱스는 단 어 ( t e r m ) 와 문 서 를 연 관 짓 는 것 
검색하기 전에 인덱스를 전처리로 만들어야 하는 것이다. 이 때문에 grep과 같이 문서가 변경되면 바로 검색결과도 바뀌는 형태의 구현은 할 수 없다. 할 수 없다기보다는 연구가 필요하다.
인덱스를 압축함으로써 컴팩트하게 가져갈 수 있고 대규모화하기도 쉽다. 또한 구현도 적절한 공수로 끝낼 수 있고 밸런스도 좋은 아키텍처다. 그래서 실제 시스템의 상당수가 채용하고 있다.
26강 검색엔진의 내부구조
역 인덱스의 내부구조는 크게 Dictionary와 Postings라는 두 파트로 나뉜 다.
언어의 단어를 term으로 만들어서 Dictionary에 담는다.
형태소를 어떻게 분해하느냐는 검색엔진의 설계나 사상에 따라 다를 수 있다.
n-gram n의 숫자로 글을 자른다. 검색쿼리도 n으로 잘라서 매치한것을 보여준다.
n-gram 분할 문제와 필터링
ex)  이승 승민  이라는 문서를 인덱싱하고 → 이승민 이라고 검색하면 나옴.
이러한 단점으로 필터링을 수행한다.
역 인덱스와 n-gram 을 기반 으로 한 역 인덱스 모두를 사용
타이틀, 코멘트，URL을 대상으로 검색 할 때 는 n - g r a m

재현률{Recall)과 적합률(Precision)
‘적합률은 높지만 재현률이 낮다’ 또는 '밸 런스 좋은 결과를 반환하고 있지만 전체적으로는 성능이 낮다’
Postings작성법
단어 사이의 근접도로 스코어링을 할 때 단어 출현위치를 사용 하곤 한다.
```
