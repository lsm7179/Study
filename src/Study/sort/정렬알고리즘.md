## 정렬 알고리즘
* [정렬 코드 보기](https://github.com/lsm7179/Study/blob/master/src/Study/sort/Sort.java)

### 선택 정렬(Selection Sort)
* 주어진 리스트에서 최솟값을 찾는다.
* 최솟값을 맨 앞자리의 값과 교환한다.
* 맨 앞자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다.
* 시간복잡도 : n(n-1)/2 -> O(n^2)
### 거품 정렬(Bubble Sort)
* 인접한 두 원소를 검사하여 정렬한다.
* 인접한 두 원소를 검사하여 순서대로 되어 있지 않으면 교환한다.
* 위와 같은 방법으로 반복한다.
* 시간복잡도 : n(n-1)/2 -> O(n^2)
### 삽입 정렬(Insertion Sort)
* 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교합니다.
* 비교하셔 자신의 위치를 찾아 삽입한다.
* 배열이 길어질수록 효율이 떨어진다.
* 선택 정렬이나 거품 정렬과 같은 O(n^2)알고리즘에 비교하여 빠르며 안정 정렬이고 in-place 알고리즘이다.
* 시간복잡도 O(n^2)
### 힙 정렬(Heap Sort)
* 최대 [힙](#heap) 트리나 최소 힙 트리를 구성해 정렬을 하는 방법이다.
* n개의 노드에 대한 [완전 이진 트리](#binary-tree)를 구성한다.
* 이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다.
* 최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다.
  가장 큰 수(루트에 위치)를 가장 작은 수와 교환한다.
* 2와 3을 반복한다.
* 시간복잡도 O(nlog n)

### 병합 정렬(Merge Sort)
### 퀵 정렬(Quick Sort)
### 카운팅 정렬(Counting sort)

#### 힙(heap)
 * 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리(complete binary tree)를 기본으로 한 자료구조(tree-based structure)이다.
 * A가 B의 부모노드(parent node) 이면, A의 키(key)값과 B의 키값 사이에는 대소관계가 성립한다.
 * 힙에는 두가지 종류가 있으며, 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙을 '최대 힙', 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙을 '최소 힙'이라고 부른다.
 * 키값의 대소관계는 오로지 부모노드와 자식노드 간에만 성립하며, 특히 형제 사이에는 대소관계가 정해지지 않는다.
#### 완전이진트리(binary tree)