## 2장 객체 생성과 파괴
이번 장은 객체의 생성과 파괴를 다룬다.
### Item1 생성자 대신 정적 팩서리 메서드를 고려하라.
```java
// from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환메서드
Date d = Date.from(instant);

//of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
Set<String> faceCards = EnumSet.of("jack", "queen", "king");

//valueOf: from과 of의 더 자세한 버전
BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);

//instance 혹은 getInstance: 인스턴스를 반환하지만 같은 인스턴스임을 보장하지는 않는다.
StackWalker luke = StackWalker.getInstance();

//create , newInstance: 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
Object newArray = Array.newInstance(classObject, arrayLen);

//getType: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
// Type은 팩터리 메서드가 반환할 객체의 타입
FileStore fs = Files.getFileStore(path);
```
### Item2 생성자에 매개변수가 많다면 빌더를 고려하라
### Item3 private 생성자나 열거 타입으로 싱글턴임을 보증하라
싱글턴이란 인스턴스를 오직 하나만 생성 할 수 있는 클래스를 말한다.
```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis(){
    }
    
    public static Elvis getInstance(){
        return INSTANCE;
    }
}
```
### Item10 equals는 일반 규약을 지켜 재정의하라
문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이다.   
* equals를 재정의해야 할 때는 언제일까?
  * 값이 같은지 알고 싶을 때 한다.(논리적 동치성을 확인하기 위해)
구체클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.   
리스코프 치환 원칙을 따라서 "상속 대신 컴포지션을 사용하라"   
새로운 equals를 재정의하면 된다.

### Item11 equals를 재정의하려거든 hashCode도 재정의하라
Object 명세 규약
> equals(Object)가 두 객체를같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.

해시테이블을 사용할때 내부적으로 hashCode로 비교하게 됨으로 재정의를 같이 해야한다.