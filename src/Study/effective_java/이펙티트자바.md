## 2장 객체 생성과 파괴
이번 장은 객체의 생성과 파괴를 다룬다.
### Item1 생성자 대신 정적 팩서리 메서드를 고려하라.
```java
// from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환메서드
Date d = Date.from(instant);

//of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
Set<String> faceCards = EnumSet.of("jack", "queen", "king");

//valueOf: from과 of의 더 자세한 버전
BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);

//instance 혹은 getInstance: 인스턴스를 반환하지만 같은 인스턴스임을 보장하지는 않는다.
StackWalker luke = StackWalker.getInstance();

//create , newInstance: 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
Object newArray = Array.newInstance(classObject, arrayLen);

//getType: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
// Type은 팩터리 메서드가 반환할 객체의 타입
FileStore fs = Files.getFileStore(path);
```
### Item2 생성자에 매개변수가 많다면 빌더를 고려하라
### Item3 private 생성자나 열거 타입으로 싱글턴임을 보증하라
싱글턴이란 인스턴스를 오직 하나만 생성 할 수 있는 클래스를 말한다.
```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis(){
    }
    
    public static Elvis getInstance(){
        return INSTANCE;
    }
}
```
### Item10 equals는 일반 규약을 지켜 재정의하라
문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이다.   
* equals를 재정의해야 할 때는 언제일까?
  * 값이 같은지 알고 싶을 때 한다.(논리적 동치성을 확인하기 위해)
구체클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.   
리스코프 치환 원칙을 따라서 "상속 대신 컴포지션을 사용하라"   
새로운 equals를 재정의하면 된다.

### Item11 equals를 재정의하려거든 hashCode도 재정의하라
Object 명세 규약
> equals(Object)가 두 객체를같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.

해시테이블을 사용할때 내부적으로 hashCode로 비교하게 됨으로 재정의를 같이 해야한다.
### Item18 상속보다는 컴포지션을 사용하라
상속은 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다.   
여기서의 상속은 구현 상속을 말한다. 인터페이스 상속과는 무관하다.   
메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.   
그러므로 상속 대신 컴포지션을 사용하라
### Item19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.
클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당하다.   
상속을 금지하는 방법은 final로 클래스를 선언하는 방법이 있다.   
다른 방법으로 모든 생성자를 private, packgae-private으로 선언하고 public 정적 팩터리를 만들어주는 방법이다.
### Item20 추상 클래스보다는 인터페이스를 우선하라.
자바8부터 인터페이스도 기본 메서드를 제공 할 수 있게 되었다.   
하여 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.
### Item21 인터페이스는 구현하는 쪽을 생각해 설계하라.
### Item22 인터페이스는 타입을 정의하는 용도로만 사용하라.
### Item23 태그 달린 클래스보다는 클래스 계층구조를 활용하라.
태그달린은 주석으로 설명해야 되는 클래스를 말하는 거 같다.
### Item24 멤버 클래스는 되도록 static으로 만들라.
## 5장 제네릭
### Item26 로 타입은 사용하지 말라.
로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.   
로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 읽게 된다.   
List같은 로 타입은 사용해서는 안 되나, List<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.
### Item27 비검사 경고를 제거하라.
할 수 있는 한 모든 비검사 경고를 제거하라.
### Item28 배열보다는 리스트를 사용하라.
배열과 제네릭은 잘 어우러지지 못한다.   
### Item29 이왕이면 제네릭 타입으로 만들라
### Item32 제네릭과 가변인수를 함께 쓸 때는 신중하라.
### Item33 타입 안전 이종 컨테이너를 고려하라.
## 6장 열거 타입과 애너테이션
### Item34 int 상수 대신 열거 타입을 사용하라
### Item35 ordinal 메서드 대신 인스턴스 필드를 사용하라.
열거 타입(enum)은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는   
ordinal이라는 메서드를 제공한다.
```java
// ordinal을 잘못 사용한 예 - 따라 하지 말것
// 유지보수하기가 어렵다.
public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET;
    
    public int numberOfMusicians() {
        return ordinal() + 1;
    }
}

// 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고, 인스턴스 필드에 저장하자.
public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3), QUARTET(4);
    
    public final int numberOfMusicians;
    
    Ensemble(int size) {
        this.numberOfMusicians = size;
    }
    
    public int numberOfMusicians(){
      return numberOfMusicians;  
    }
}
```
### Item36 비트 필드 대신 EnumSet을 사용하라.
### Item37 ordinal 인덱싱 대신 EnumMap을 사용하라.
### Item38 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.
### Item39 명명 패턴보다 애너테이션을 사용하라.
### Item40 @Override 애너테이션을 일관되게 사용하라.
### Item41 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.
아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 마커 인터페이스(marker interface)라 한다.
## 7장 람다와 스트림
### Item42 익명 클래스보다는 람다를 사용하라.
### Item43 람다보다는 메서드 참조를 사용하라.